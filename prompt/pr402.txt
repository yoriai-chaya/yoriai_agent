

[Question]
FastAPI, Pythonã§ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã‚µãƒ¼ãƒã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’é–‹ç™ºã—ã¦ã„ã¾ã™ã€‚
ä¸‹è¨˜ã«ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ç¤ºã—ã¾ã™ã€‚

## ä¾é ¼äº‹é …
ä»¥ä¸‹ã®æ–¹é‡ã«åŸºã¥ãã€ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¿®æ­£æ¡ˆã‚’ç¤ºã—ã¦ãã ã•ã„ã€‚

### æ–¹é‡
- é–¢æ•°run_buildã¯ã€buildã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°ã§ã‚ã‚‹ã€‚
- é–¢æ•°run_buildã®ä¸­ã§ã¯ä»¥ä¸‹ã®äº‹é …ã‚’åˆ¤å®šã—ã¦ã„ã‚‹ã€‚
  - Case-1:buildã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã§ã‚ã‚Œã°FunctionResultã®abort_flgã‚’Falseã«ã‚»ãƒƒãƒˆã—ã¦è¿”å´ã—ã¦ã„ã‚‹
  - Case-2:buildã‚¨ãƒ©ãƒ¼ã§ãƒªãƒˆãƒ©ã‚¤ä¸å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã§ã‚ã‚Œã°FunctionResultã®abort_flgã‚’Trueã«ã‚»ãƒƒãƒˆã—ã¦è¿”å´ã—ã¦ã„ã‚‹
  - Case-3:buildãŒæˆåŠŸã™ã‚Œã°FunctionResultã®abort_flgã¯Falseã§ã€ã‹ã¤ã€result=Trueã‚’ã‚»ãƒƒãƒˆã—ã¦è¿”å´ã—ã¦ã„ã‚‹
- ã“ã®åˆ¤å®šã«åŸºã¥ãã€é–¢æ•°run_build_stepã§ã¯ã€ãã‚Œãã‚Œã®ã‚±ãƒ¼ã‚¹ã«å¿œã˜ãŸsse_eventsã‚’è¿½åŠ ã—ã¦StepResultã‚’è¿”å´ã—ã¦ã„ã‚‹ã€‚
- é–¢æ•°handle_gen_codeã§ã¯ã€é–¢æ•°run_build_stepã®è¿”å´å€¤ã«å¾“ã„ã€
  - Case-1ã®ã¨ãã¯ãƒ“ãƒ«ãƒ‰ã®ãƒªãƒˆãƒ©ã‚¤ã€ã¤ã¾ã‚Šé–¢æ•°run_rebuild_stepã‚’å‘¼ã³å‡ºã™ï¼ˆç¾çŠ¶é€šã‚Šï¼‰
  - Case-2ã®ã¨ãã¯sse_eventsã‚’é€ä¿¡ã—ãŸå¾Œã€DonePayload(DoneStatus.FAILED)ã‚’é€ä¿¡ã—ãŸã„ï¼ˆç¾çŠ¶ã€ã“ã‚ŒãŒé€ä¿¡ã•ã‚Œãªã„ã®ã§ã¯ãªã„ã‹ï¼Ÿï¼‰
  - Case-3ã®ã¨ãã¯ã€Œ# Doneã€ã‚³ãƒ¡ãƒ³ãƒˆæ–‡ã®å‡¦ç†ã€ã¤ã¾ã‚Šã€logger.info()ã‚’å‡ºåŠ›ã—ã€DonePayload(DoneStatus.COMPLETED)ã‚’é€ä¿¡ã—ãŸã„ï¼ˆç¾çŠ¶ã€ã“ã‚Œã‚‚é€ä¿¡ã—ã¦ã„ãªã„ï¼Ÿï¼‰
- é–¢æ•°run_rebuild_stepãŒå‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã€ã‚¨ãƒ©ãƒ¼ã‚’è§£æ¶ˆã—ãŸå¾Œã€å†åº¦ã€ãƒ“ãƒ«ãƒ‰ã‚’å®Ÿæ–½ã—ãŸã„ï¼ˆç¾çŠ¶æœªå®Ÿè£…ã€‚SubStep-3ï¼‰ã€‚é–¢æ•°run_buildã‚’å‘¼ã³å‡ºã™ã€‚
- ãŸã ã—ã€é–¢æ•°run_buildã®åˆ¤å®šçµæœã®å–ã‚Šæ‰±ã„ã«ã¤ã„ã¦ã¯ã€é–¢æ•°run_build_stepã¨ç•°ãªã‚Šã€Case-1ã®ã¨ãã‚‚Case-2ã®ã¨ãã‚‚ã€DonePayload(DoneStatus.FAILED)ã‚’é€ä¿¡ã—ãŸã„ã€‚Case-3ã®ã¨ãã¯ã€Œ# Doneã€ã‚³ãƒ¡ãƒ³ãƒˆæ–‡ã®å‡¦ç†ã€ã¤ã¾ã‚Šã€logger.info()ã‚’å‡ºåŠ›ã—ã€DonePayload(DoneStatus.COMPLETED)ã‚’é€ä¿¡ã—ãŸã„ã€‚

ã‹ãªã‚Šè¤‡é›‘ã«ãªã£ã¦ã„ã¾ã™ãŒã€å…¨ä½“ã‚’é€šã—ã¦æ¥µåŠ›ã‚ã‹ã‚Šã‚„ã™ãè¨˜è¿°ã—ãŸã„ã€‚
æƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã‚Œã°ã€è³ªå•ã—ã¦ãã ã•ã„ã€‚


## ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ (gen_code_handler.py)
"""
A handler for code generation, ESLint checking, and build checking

Notes:
(1)error_payload
    In the following statement:
    error_payload = SystemError(error="Unexpected error", detail=str(e))
    The error value (e.g., "Unexpected error") is displayed in the frontend UI (Left-Panel)
    Keep this error message within 20 characters.
"""

from typing import AsyncIterator, Awaitable, Callable

from base import (
    DebugMode,
    DonePayload,
    DoneStatus,
    EventType,
    LocalContext,
    LoopAction,
    SystemError,
)
from checkpoint import debug_checkpoint
from config import Settings
from logger import logger
from step_check_code import check_code_step
from step_gen_code import gen_code_step
from step_run_build import run_build_step
from step_run_rebuild import run_rebuild_step

SSEEventCallable = Callable[[str, dict], Awaitable[str]]


async def handle_gen_code(
    prompt: str,
    context: LocalContext,
    settings: Settings,
    sse_event: SSEEventCallable,
) -> AsyncIterator[str]:
    """
    Overview:
        A handler that performs code generation, ESLint checks, and build verification.

    Description:
        This handler executes the following steps:

        1. Generate code based on a given prompt.
           If necessary, additional text may be appended to the prompt
           (e.g., when ESLint errors occur, supplementary instructions are added
           to help avoid those errors).

        2. Perform static analysis on the generated code using ESLint.

        3. If the static check passes, run the build command to detect errors
           that ESLint cannot catch
           (e.g., when using useState, a build error occurs if "use client"
           is missing).

        4. If an error occurs in steps (2) or (3), retry the code generation
           process up to the maximum number of retry attempts.
    """
    try:
        category = context.category
        logger.info(f"[{category}]: Start Code Generation")

        # Completed payload (may be overwritten)
        final_payload = DonePayload(
            status=DoneStatus.COMPLETED,
            message="All Tasks Completed",
        )

        debug_mode = DebugMode.CONTINUE
        next_prompt = prompt

        # =========================
        # Code Generation Loop
        # =========================
        success = False
        for i in range(settings.code_gen_retry):
            logger.debug(f"Code Gen Loop [{i}]")

            # -------------------------------
            # 1. Create Code (prepare prompt)
            # -------------------------------
            final_prompt = next_prompt
            add_prompts_len = len(context.add_prompts)

            logger.debug(
                f"[Prompt] Base prompt len={len(final_prompt)}, "
                f"number of additional prompts={add_prompts_len}"
            )

            if add_prompts_len != 0:
                logger.debug("[Prompt] Extending prompt with additional messages")
                for add_prompt in context.add_prompts:
                    logger.debug(f"[Prompt] Additional prompt: {add_prompt}")
                    final_prompt = f"{final_prompt}\n- {add_prompt}\n"
                    logger.debug(f"final_prompt: {final_prompt}")

            # --------------------------------------------
            # 2. CP1: Debug Checkpoint - before gen_code()
            # --------------------------------------------
            logger.debug(f"[CP1] Current debug_mode: {debug_mode}")
            if settings.debug:
                debug_mode = await debug_checkpoint(
                    cp_name="CP1",
                    current_mode=debug_mode,
                )
                if debug_mode == DebugMode.END:
                    logger.debug("[CP1] Exiting loop")
                    break

            # ------------------
            # 3. Call gen_code()
            # ------------------
            if debug_mode != DebugMode.SKIP_AGENT:
                logger.debug("gen_code_step called")
                step = await gen_code_step(
                    final_prompt=final_prompt,
                    context=context,
                )

                for ev in step.sse_events:
                    yield await sse_event(ev.event, ev.payload)

                if step.final_payload:
                    final_payload = step.final_payload

                if step.action == LoopAction.CONTINUE:
                    continue
                if step.action == LoopAction.BREAK:
                    break
            else:
                logger.debug("[gen_code] Skipping gen_code()")

            # --------------------------------------------------
            # 4. CP2: Debug Checkpoint - before check_gen_code()
            # --------------------------------------------------
            logger.debug(f"[CP2] Current debug_mode: {debug_mode}")
            if settings.debug:
                debug_mode = await debug_checkpoint(
                    cp_name="CP2",
                    current_mode=debug_mode,
                )
                if debug_mode == DebugMode.END:
                    logger.debug("[CP2] Exiting loop")
                    break

            # ------------------------
            # 5. Call check_gen_code()
            # ------------------------
            if debug_mode != DebugMode.SKIP_AGENT:
                logger.debug("check_code_step called")
                step = await check_code_step(
                    prompt=prompt,
                    context=context,
                )

                for ev in step.sse_events:
                    yield await sse_event(ev.event, ev.payload)

                if step.action == LoopAction.CONTINUE:
                    continue
                if step.action == LoopAction.BREAK:
                    success = True
                    break
            else:
                logger.debug("[check_gen_code] Skipping check_gen_code()")

        # ---------------------------------------------
        # 6. Retry Limit Check
        # ---------------------------------------------
        if not success:
            logger.error("[retry limit check] Retry limit exceeded")
            final_payload = DonePayload(
                status=DoneStatus.FAILED,
                message="Retry Limit exceeded",
            )
            yield await sse_event(EventType.DONE, final_payload.model_dump())
            return

        # ---------------------------------------------
        # 7. CP3: Debug Checkpoint - before run_build()
        # ---------------------------------------------
        logger.debug(f"[CP3] Current debug_mode: {debug_mode}")
        if settings.debug:
            debug_mode = await debug_checkpoint(
                cp_name="CP3",
                current_mode=debug_mode,
                context=context,
            )

        # -------------------
        # 8. Call run_build()
        # -------------------
        logger.debug(f"[run_build] context.build_check: {context.build_check}")
        rebuild_flg = False
        if context.build_check and debug_mode != DebugMode.SKIP_AGENT:
            logger.debug("run_build_step called")
            step_result = await run_build_step(
                context=context,
                settings=settings,
            )

            for ev in step_result.sse_events:
                yield await sse_event(ev.event, ev.payload)

            if step_result.final_payload:
                final_payload = step_result.final_payload

            if step_result.result is not None:
                if step_result.result.abort_flg:
                    yield await sse_event(
                        EventType.DONE,
                        final_payload.model_dump(),
                    )
                    return

            if step_result.result is not None:
                rebuild_flg = True

        # ---------------------
        # 9. Call run_rebuild()
        # ---------------------
        build_result = step_result.result
        if rebuild_flg:
            if (
                build_result is not None
                and context.build_check
                and debug_mode != DebugMode.SKIP_AGENT
                and not build_result.result
            ):
                async for ev in run_rebuild_step(
                    context=context,
                    build_result=build_result,
                ):
                    yield await sse_event(ev.event, ev.payload)

    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        error_payload = SystemError(
            error="Unexpected error",
            detail=str(e),
        )
        yield await sse_event(
            EventType.SYSTEM_ERROR,
            error_payload.model_dump(),
        )
        final_payload = DonePayload(
            status=DoneStatus.FAILED,
            message="unexpected error occurred",
        )

    # =========================
    # Done
    # =========================
    logger.info(f"[{category}]: All Tasks Completed")
    yield await sse_event(
        EventType.DONE,
        final_payload.model_dump(),
    )

## ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ (step_run_build.py)
from base import (
    DonePayload,
    DoneStatus,
    EventType,
    LocalContext,
    SSEPayload,
    StepResult,
)
from config import Settings
from logger import logger
from run_build_cmd import run_build


async def run_build_step(
    context: LocalContext,
    settings: Settings,
) -> StepResult:
    sse_events: list[SSEPayload] = []

    logger.debug("[run_build] Call run_build()")
    build_result = await run_build(context, settings)

    if not build_result.result:
        # Case-1: The build command could not be executed due to a system-level error.
        # Case-2: The build command completed, but the build output contains errors.
        logger.error(f"[run_build] Build failed: {build_result.detail}")
        sse_events.append(
            SSEPayload(
                event=EventType.CHECK_RESULT,
                payload={
                    "checker": "Build",
                    "result": False,
                    "rule_id": "npm run build",
                    "detail": build_result.detail,
                },
            )
        )
        return StepResult(
            result=build_result,
            sse_events=sse_events,
            final_payload=DonePayload(
                status=DoneStatus.FAILED,
                message="Build failed",
            ),
        )

    # Case-3: The build command completed successfully with no errors detected.
    sse_events.append(
        SSEPayload(
            event=EventType.CHECK_RESULT,
            payload={
                "checker": "Build",
                "result": True,
                "rule_id": "",
                "detail": "",
            },
        )
    )
    return StepResult(result=build_result, sse_events=sse_events)

## ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ (step_run_rebuild.py)
import json
from typing import AsyncIterator

from base import (
    BuildErrorAnalyzerResult,
    EventType,
    FunctionResult,
    LocalContext,
    SSEPayload,
    SystemError,
)
from build_error_analysis import analyze_build_error
from code_fixer import fix_code
from logger import logger


async def run_rebuild_step(
    context: LocalContext, build_result: FunctionResult
) -> AsyncIterator[SSEPayload]:
    logger.debug("run_rebuild_step called")

    try:
        # SubStep-1: Build Error Analysis
        analyzer_result: BuildErrorAnalyzerResult | None = None
        logger.debug("[gen_code] Call gen_code()")
        async for line in analyze_build_error(
            context=context, build_result=build_result
        ):
            # Events: AGENT_UPDATE, ANALYZER_RESULT
            data = json.loads(line)
            yield SSEPayload(
                event=EventType(data["event"]), payload=data.get("payload", {})
            )
            if data["event"] == EventType.ANALYZER_RESULT:
                analyzer_result = BuildErrorAnalyzerResult(**data["payload"])

        # SubStep-2: Fix Code
        if analyzer_result is None:
            raise ValueError("analyzer_result is None")

        logger.debug(f"analyzer_result: {analyzer_result}")
        async for line in fix_code(context=context, analyzer_result=analyzer_result):
            # Events: AGENT_RESULT
            data = json.loads(line)
            yield SSEPayload(
                event=EventType(data["event"]), payload=data.get("payload", {})
            )

        # SubStep-3: Validate Code (re-build)
        # ã“ã“ã‚’ä½œæˆã—ãŸã„ã€‚

    except Exception as e:
        logger.error(f"Exception: {e}")
        yield SSEPayload(
            event=EventType.SYSTEM_ERROR,
            payload=SystemError(error="Unexpected Error", detail=str(e)).model_dump(),
        )

## ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ (run_build_cmd.py)
import json
from pathlib import Path
from subprocess import CompletedProcess
from typing import List

from base import FunctionResult, LocalContext
from config import Settings
from logger import logger
from run_command import run_cmd


def load_json(path: Path) -> dict:
    with path.open("r", encoding="utf-8") as file:
        return json.load(file)


def extract_stderr_messages(records: List[dict]) -> List[str]:
    return [r.get("message", "") for r in records if r.get("stream") == "stderr"]


async def run_build(context: LocalContext, settings: Settings) -> FunctionResult:
    logger.debug("run_build called")
    cwd = str(context.output_dir)
    logger.debug(f"cwd: {cwd}")
    build_dir = context.stepid_dir / "build"
    build_dir.mkdir(exist_ok=True)

    output_path = build_dir / "build.log"
    logger.debug(f"output_path: {output_path}")

    option = f"--logs-dir={str(build_dir)}"
    command = ["npm", "run", "build:agent", "--", option]
    logger.debug(f"stepid_dir: {context.stepid_dir}")

    try:
        cmd_result: CompletedProcess = run_cmd(
            stepid_dir=context.stepid_dir,
            command=command,
            output_path=output_path,
            cwd=cwd,
        )
        logger.debug(f"cmd_result: {cmd_result}")
    except FileNotFoundError as e:
        logger.error(f"Build failed : {e}")
        detail = str(e)
        return FunctionResult(result=False, abort_flg=True, detail=detail)

    customconfig_dir = context.output_dir
    customconfig_file = settings.build_customconfig_file
    customconfig_path = customconfig_dir / customconfig_file
    logger.debug(f"customconfig_path: {customconfig_path}")

    try:
        with open(customconfig_path, "r", encoding="utf-8") as f:
            customconfig = json.load(f)
        build_report_file = customconfig.get("build_report_file")
        if not build_report_file:
            detail = "Failed to get build_report_file"
            logger.error(detail)
            return FunctionResult(result=False, abort_flg=True, detail=detail)
    except Exception as e:
        detail = f"Failed to build-customconfig file: {e}"
        logger.error(detail)
        return FunctionResult(result=False, abort_flg=True, detail=detail)

    logger.debug(f"build_report_file: {build_report_file}")
    build_report_path = build_dir / build_report_file
    logger.debug(f"build_report_path: {build_report_path}")
    if not build_report_path.exists():
        detail = f"{build_report_path} does not exist."
        return FunctionResult(result=False, abort_flg=True, detail=detail)

    result_data = load_json(build_report_path)

    error_count = int(result_data.get("summary", {}).get("errorCount", 0))
    if error_count == 0:
        # Build Successful
        logger.debug(f"No errors : error_count={error_count}")
        return FunctionResult(result=True, abort_flg=False, detail="")

    # Build Errors
    records = result_data.get("records", [])
    messages = extract_stderr_messages(records)

    result_detail = "".join(m + "\n" for m in messages)
    logger.debug(f"Build Errors - result_detail: {result_detail}")

    return FunctionResult(result=False, abort_flg=False, detail=result_detail)

äº†è§£ã§ã™ã€‚ã‹ãªã‚Šæ•´ç†ã•ã‚ŒãŸè¨­è¨ˆæ€æƒ³ã‚’ãŠæŒã¡ãªã®ã§ã€
**ã€Œè²¬å‹™ã®åˆ†é›¢ã€ã¨ã€ŒCaseåˆ¤å®šã®ä¸€å…ƒåŒ–ã€**ã‚’æ„è­˜ã—ã¦ç›´ã™ã¨ã€å…¨ä½“ãŒã‹ãªã‚Šèª­ã¿ã‚„ã™ããªã‚Šã¾ã™ ğŸ‘

ä»¥ä¸‹ã§ã¯ã€

1. **å…¨ä½“æ–¹é‡ã®æ•´ç†ï¼ˆã©ã†ç›´ã™ã‹ã®åœ°å›³ï¼‰**
2. **è¨­è¨ˆä¸Šã®ã‚­ãƒ¼ã‚¢ã‚¤ãƒ‡ã‚¢**
3. **å…·ä½“çš„ãªä¿®æ­£æ¡ˆï¼ˆã‚³ãƒ¼ãƒ‰ä¾‹ï¼‰**

   * `run_build_step`
   * `run_rebuild_step`
   * `handle_gen_code`

ã®é †ã§èª¬æ˜ã—ã¾ã™ã€‚

---

## 1. å…¨ä½“æ–¹é‡ã®æ•´ç†ï¼ˆã¾ãšä½•ã‚’æƒãˆã‚‹ã‹ï¼‰

ä»Šå›ã®æ··ä¹±ãƒã‚¤ãƒ³ãƒˆã¯ã“ã“ã§ã™ï¼š

* `run_build` ã¯ **Caseåˆ¤å®šã®äº‹å®Ÿã ã‘**ã‚’è¿”ã—ã¦ã„ã‚‹ï¼ˆğŸ‘ è‰¯ã„ï¼‰
* ã—ã‹ã—

  * `run_build_step`
  * `handle_gen_code`
  * `run_rebuild_step`

  ãã‚Œãã‚Œã§
  **ã€ŒCase-1/2/3ã®è§£é‡ˆã€ã¨ã€ŒDoneã‚’é€ã‚‹ã‹ã©ã†ã‹ã€**ãŒãƒãƒ©ãƒãƒ©

ğŸ‘‰ ãã“ã§ï¼š

### âœ¨ æ–¹é‡ã®æ ¸å¿ƒ

* **Caseåˆ¤å®šã¯ `FunctionResult` ã®ã¿ã§è¡¨ç¾**
* **ã€Œã©ã†çµ‚ã‚ã‚‹ã‹ï¼ˆDoneStatusï¼‰ã€ã¯å‘¼ã³å‡ºã—å´ãŒæ±ºã‚ã‚‹**
* `run_build_step` / `run_rebuild_step` ã¯
  ğŸ‘‰ *SSEã‚¤ãƒ™ãƒ³ãƒˆã‚’ç©ã‚€ã ã‘*
  ğŸ‘‰ *DonePayloadã¯æ¥µåŠ›è¿”ã•ãªã„*

---

## 2. Caseå®šç¾©ã‚’ã‚³ãƒ¼ãƒ‰ã§å›ºå®šã™ã‚‹

ã¾ãšã€ã‚ãªãŸã®æ–‡ç« ã‚’ **ã‚³ãƒ¼ãƒ‰ä¸Šã®çœŸå®Ÿ**ã¨ã—ã¦å›ºå®šã—ã¾ã™ã€‚

```text
FunctionResult ã®æ„å‘³

Case-1:
  result=False, abort_flg=False  # ãƒªãƒˆãƒ©ã‚¤å¯èƒ½

Case-2:
  result=False, abort_flg=True   # ãƒªãƒˆãƒ©ã‚¤ä¸å¯ï¼ˆè‡´å‘½çš„ï¼‰

Case-3:
  result=True, abort_flg=False   # æˆåŠŸ
```

ã“ã®3ã¤ã ã‘ã‚’ä¿¡ã˜ã¦åˆ†å²ã—ã¾ã™ã€‚

---

## 3. ä¿®æ­£æ¡ˆï¼ˆå…·ä½“ã‚³ãƒ¼ãƒ‰ï¼‰

---

## 3.1 `step_run_build.py`ï¼ˆè²¬å‹™ã‚’æœ€å°åŒ–ï¼‰

### ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆ

* `DonePayload` ã‚’è¿”ã•ãªã„
* **buildçµæœã‚’SSEã§é€šçŸ¥ã™ã‚‹ã ã‘**

```python
# step_run_build.py
from base import (
    EventType,
    LocalContext,
    SSEPayload,
    StepResult,
)
from config import Settings
from logger import logger
from run_build_cmd import run_build


async def run_build_step(
    context: LocalContext,
    settings: Settings,
) -> StepResult:
    sse_events: list[SSEPayload] = []

    logger.debug("[run_build] Call run_build()")
    build_result = await run_build(context, settings)

    # å…±é€šã§ CHECK_RESULT ã¯å¿…ãšå‡ºã™
    sse_events.append(
        SSEPayload(
            event=EventType.CHECK_RESULT,
            payload={
                "checker": "Build",
                "result": build_result.result,
                "rule_id": "npm run build",
                "detail": build_result.detail,
            },
        )
    )

    return StepResult(
        result=build_result,
        sse_events=sse_events,
    )
```

ğŸ‘‰ **Caseåˆ¤å®šã¯ä¸€åˆ‡ã—ãªã„**
ğŸ‘‰ ã€Œã“ã‚Œã¯ãƒªãƒˆãƒ©ã‚¤ï¼Ÿçµ‚äº†ï¼Ÿã€ã¯å‘¼ã³å‡ºã—å…ƒã¸

---

## 3.2 `step_run_rebuild.py`ï¼ˆSubStep-3 å®Ÿè£…ï¼‰

### è¿½åŠ è¦ä»¶

* ä¿®æ­£å¾Œã« **å†åº¦ build**
* ãã®çµæœã«å¿œã˜ã¦ **Doneã¯ handle_gen_code å´ã§é€ã‚‹**

```python
# step_run_rebuild.pyï¼ˆè¿½è¨˜éƒ¨åˆ†ã®ã¿ï¼‰
from config import Settings
from step_run_build import run_build_step

# SubStep-3: Validate Code (re-build)
logger.debug("[rebuild] Re-run build after fix")

step_result = await run_build_step(
    context=context,
    settings=context.settings,  # context ã«æŒãŸã›ã‚‹ or å¼•æ•°è¿½åŠ 
)

for ev in step_result.sse_events:
    yield ev

# buildçµæœã¯å‘¼ã³å‡ºã—å…ƒã§åˆ¤æ–­ã•ã›ã‚‹
yield SSEPayload(
    event=EventType.INTERNAL_RESULT,
    payload={
        "result": step_result.result.model_dump()
    },
)
```

â€» `INTERNAL_RESULT` ã®ã‚ˆã†ãªå†…éƒ¨ç”¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½¿ã†ã‹ã€
`run_rebuild_step` ã®æˆ»ã‚Šå€¤ã‚’ `AsyncIterator[SSEPayload | FunctionResult]` ã«ã—ã¦ã‚‚OKã§ã™ã€‚

---

## 3.3 `handle_gen_code`ï¼ˆä¸€ç•ªé‡è¦ï¼‰

### ãƒã‚¤ãƒ³ãƒˆ

* **Doneã‚’é€ã‚‹å ´æ‰€ã‚’ã“ã“ã«ä¸€æœ¬åŒ–**
* Caseã”ã¨ã®æŒ¯ã‚‹èˆã„ã‚’æ˜ç¤º

### buildã€œrebuildéƒ¨åˆ†ã®ä¿®æ­£ä¾‹

```python
# --- 8. Call run_build_step ---
step_result = await run_build_step(context, settings)

for ev in step_result.sse_events:
    yield await sse_event(ev.event, ev.payload)

build_result = step_result.result
if build_result is None:
    raise RuntimeError("build_result is None")

# ===== Case åˆ¤å®š =====
# Case-2: ãƒªãƒˆãƒ©ã‚¤ä¸å¯
if build_result.abort_flg:
    logger.error("[build] abort_flg=True -> FAILED")
    yield await sse_event(
        EventType.DONE,
        DonePayload(
            status=DoneStatus.FAILED,
            message="Build failed (abort)",
        ).model_dump(),
    )
    return

# Case-3: æˆåŠŸ
if build_result.result:
    logger.info("# Done")
    yield await sse_event(
        EventType.DONE,
        DonePayload(
            status=DoneStatus.COMPLETED,
            message="Build completed",
        ).model_dump(),
    )
    return

# Case-1: ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ â†’ rebuild
logger.info("[build] retryable error -> rebuild")

async for ev in run_rebuild_step(
    context=context,
    build_result=build_result,
):
    yield await sse_event(ev.event, ev.payload)

# rebuild å¾Œã® build çµæœã‚‚åŒã˜ãƒ«ãƒ¼ãƒ«ã§å‡¦ç†
# ï¼ˆCase-1/2 â†’ FAILED, Case-3 â†’ COMPLETEDï¼‰
```

ğŸ‘‰ ã“ã‚Œã§ï¼š

| ã‚±ãƒ¼ã‚¹    | run_build                     | handle_gen_code                    |
| ------ | ----------------------------- | ---------------------------------- |
| Case-1 | abort_flg=False, result=False | rebuild â†’ æœ€çµ‚çš„ã« FAILED or COMPLETED |
| Case-2 | abort_flg=True                | å³ FAILEDï¼ˆDoneé€ä¿¡ï¼‰                   |
| Case-3 | result=True                   | å³ COMPLETEDï¼ˆDoneé€ä¿¡ï¼‰                |

---

## 4. ã“ã®æ§‹æˆã®ãƒ¡ãƒªãƒƒãƒˆ

* âœ… **Caseå®šç¾©ãŒä¸€ç®‡æ‰€ã«é›†ç´„**
* âœ… `run_build` / `run_build_step` ãŒç´”ç²‹é–¢æ•°ã£ã½ããªã‚‹
* âœ… ã€ŒDoneãŒé€ã‚‰ã‚Œãªã„ã‹ã‚‚ï¼Ÿã€ã¨ã„ã†ä¸å®‰ãŒæ¶ˆãˆã‚‹
* âœ… SubStep-3ï¼ˆå†buildï¼‰ãŒè‡ªç„¶ã«çµ„ã¿è¾¼ã‚ã‚‹

---

## 5. æ¬¡ã«ã‚„ã‚‹ã¨è‰¯ã„æ”¹å–„ï¼ˆä»»æ„ï¼‰

* `BuildCase = Enum("RETRYABLE", "ABORT", "SUCCESS")` ã‚’ä½œã‚‹
* `FunctionResult â†’ case` ã«å¤‰æ›ã™ã‚‹å°é–¢æ•°ã‚’ä½œã‚‹
* `handle_gen_code` ã® build éƒ¨åˆ†ã‚’åˆ¥é–¢æ•°ã«åˆ‡ã‚Šå‡ºã™

---

ã‚‚ã—æ¬¡ã«é€²ã‚€ãªã‚‰ï¼š

* `run_rebuild_step` ã® **æˆ»ã‚Šå€¤è¨­è¨ˆï¼ˆIterator vs Resultï¼‰**
* `INTERNAL_RESULT` ã‚’ä½¿ã‚ãªã„è¨­è¨ˆ
* build / rebuild å…±é€šãƒãƒ³ãƒ‰ãƒ©åŒ–

ã“ã®ã‚ãŸã‚Šã€ã©ã‚Œã‚’æ·±æ˜ã‚Šã—ã¾ã™ï¼Ÿ

