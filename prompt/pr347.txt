

[Question]
Next.js, TailwindCSS, Shadcn/ui, TypeScriptã‚’ç”¨ã„ã¦ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹ç™ºã—ã¦ã„ã¾ã™ã€‚

ä¸‹è¨˜ã«ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ 
- page.tsx
- QA.tsx
- useSSEPrompt.ts
- types.ts
ã‚’ç¤ºã—ã¾ã™ã€‚

ä»¥ä¸‹ã®è¦³ç‚¹ã§ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è§£æã—ã€å‡¦ç†æ¦‚è¦ã‚’èª¬æ˜ã—ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ æ”¹ä¿®ã®æ–¹é‡ã‚’æ•´ç†ã—ã¦ãã ã•ã„ã€‚

## è¦³ç‚¹
- ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€æŒ‡å®šã—ãŸãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ï¼‰ã‚’èª­ã¿è¾¼ã¿ã€ã“ã‚Œã‚’ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ–‡ã¨ã—ã¦ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã‚µãƒ¼ãƒã«é€ä¿¡ã™ã‚‹å‡¦ç†ã‚’è¡Œã£ã¦ã„ã‚‹ã€‚
- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã‚µãƒ¼ãƒã‹ã‚‰ã¯ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ–‡ã‚’LLMã«æŠ•ã’ã¦å„ç¨®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå‡¦ç†ã‚’è¡Œã„ã€ãã®çµæœã¯Streamingãƒ‡ãƒ¼ã‚¿(SSE)ã§ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å´ã«é€ã‚‰ã‚Œã¦ãã‚‹ã€‚ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é©å®œãƒ–ãƒ©ã‚¦ã‚¶ã«è¡¨ç¤ºã—ã¦ã„ã‚‹ã€‚
- ç¾çŠ¶ã¯ã€<QA>ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§useSSEPrompt.tsã§å®šç¾©ã—ã¦ã„ã‚‹sendPrompt()é–¢æ•°ã§APIã‚µãƒ¼ãƒã«é€ä¿¡ã—ã¦ã„ã‚‹ã€‚
- ã“ã®å‡¦ç†ã‚’ä»Šå¾Œã¯ã€æ–°ãŸã«ä½œæˆã™ã‚‹åˆ¥ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‹ã‚‰ã‚‚ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ–‡ã‚’é€ä¿¡ã™ã‚‹ãŸã‚ã«ã€sendPrompt()é–¢æ•°ã‚’ç”¨ã„ãŸã„ã¨æ€ã£ã¦ã„ã‚‹ã€‚
- ä»Šå›ã¯ã“ã®sendPrompt()é–¢æ•°ã‚’åˆ¥ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‹ã‚‰å‘¼ã³å‡ºã™ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã‹ã€ã¾ãŸã€ãã®éš›ã®å‡¦ç†æ¡ä»¶ã‚’è¦‹æ¥µã‚ãŸã„ã€‚

ãƒ—ãƒ­ã‚°ãƒ©ãƒ è§£æã«ã‚ãŸã‚Šã€ä¸è¶³ã™ã‚‹æƒ…å ±ãŒã‚ã‚Œã°è³ªå•ã—ã¦ãã ã•ã„ã€‚

## ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ (page.tsx)
"use client";
import { useEffect, useReducer, useState, useRef } from "react";
import { Separator } from "@/components/ui/separator";
import { ScrollArea } from "@/components/ui/scroll-area";
import FileUploader from "./FileUploader";
import QA from "./QA";
import ShowPrompt from "./ShowPrompt";
import StreamDetail from "./StreamDetail";
import Header from "./Header";
import { State, FileInfo, ResponseInfo, Mode } from "./types";
import { reducer } from "./reducer";
import AutoBlock from "./AutoBlock";

const initialState: State = {
  steps: [{ status: "Unloaded" }],
};
const initialFileInfo: FileInfo[] = [
  { filename: "", content: "", mtime: new Date(0) },
];
const initialResponseInfo: ResponseInfo[] = [];

export default function App() {
  const [state, dispatch] = useReducer(reducer, initialState);
  const [fileInfo, setFileInfo] = useState<FileInfo[]>(initialFileInfo);
  const [responseInfo, setResponseInfo] =
    useState<ResponseInfo[]>(initialResponseInfo);
  const [mode, setMode] = useState<Mode>("Manual");
  useEffect(() => {
    console.log("fileInfo updated: ", fileInfo);
    scrollRightPanel();
  }, [fileInfo]);
  useEffect(() => {
    console.log("state updated: ", state);
    scrollLeftPanel();
  }, [state]);
  useEffect(() => {
    console.log("responseInfo updated: ", responseInfo);
    scrollLeftPanel();
    scrollRightPanel();
  }, [responseInfo]);
  useEffect(() => {
    setFileInfo((prev) => {
      if (prev.length >= state.steps.length) return prev;
      return [...prev, { filename: "", content: "", mtime: new Date(0) }];
    });
  }, [state.steps.length]);

  const rightPanel = useRef<HTMLDivElement>(null);
  const leftPanel = useRef<HTMLDivElement>(null);

  const scrollRightPanel = () => {
    if (rightPanel.current) {
      rightPanel.current.scrollIntoView({
        behavior: "smooth",
        block: "end",
      });
    }
  };
  const scrollLeftPanel = () => {
    if (leftPanel.current) {
      leftPanel.current.scrollIntoView({
        behavior: "smooth",
        block: "end",
      });
    }
  };

  return (
    <div className="flex flex-col h-screen overflow-hidden">
      {/* Header */}
      <Header mode={mode} setMode={setMode} />

      {/* Main Area */}
      <div className="flex flex-1 overflow-hidden">
        {/* Side-Panel */}
        <ScrollArea className="w-3/15 p-4Â border-r space-y-4">
          <div>
            <p>Auto Mode Panel</p>
            <AutoBlock />
          </div>
        </ScrollArea>
        {/* Left-Panel */}
        <ScrollArea className="w-6/15 p-4Â border-r space-y-4">
          <div ref={leftPanel}>
            {state.steps.map((step, index) => (
              <div key={index}>
                <p className="text-app-step my-2">
                  Step {index} - Status: {step.status}
                </p>
                <FileUploader
                  index={index}
                  status={step.status}
                  dispatch={dispatch}
                  setFileInfo={setFileInfo}
                />
                <QA
                  index={index}
                  status={step.status}
                  dispatch={dispatch}
                  fileInfo={fileInfo[index]}
                  setResponseInfo={setResponseInfo}
                  responseInfo={responseInfo[index]}
                />
                <Separator />
              </div>
            ))}
          </div>
        </ScrollArea>
        {/* Right-Panel */}
        <ScrollArea className="w-6/15 p-4Â border-r space-y-4">
          <div ref={rightPanel}>
            {state.steps.map((step, index) => (
              <div key={index}>
                <p className="text-app-step my-2">
                  Step {index} - Status: {step.status}
                </p>
                <ShowPrompt
                  index={index}
                  status={step.status}
                  fileInfo={fileInfo}
                />
                <StreamDetail
                  status={step.status}
                  responseInfo={responseInfo[index]}
                />
              </div>
            ))}
          </div>
        </ScrollArea>
      </div>
    </div>
  );
}

## ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ (QA.tsx)
"use client";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { SendHorizontal } from "lucide-react";
import StreamEvent from "./StreamEvent";
import { Action, FileInfo } from "./types";
import { ResponseInfo } from "./types";
import { formatDateTime } from "./util";
import { useState } from "react";
import { useSSEPrompt } from "./useSSEPrompt";

interface QAProps {
  status: string;
  index: number;
  dispatch: React.Dispatch<Action>;
  fileInfo: FileInfo;
  setResponseInfo: React.Dispatch<React.SetStateAction<ResponseInfo[]>>;
  responseInfo: ResponseInfo;
}

const QA = ({
  status,
  index,
  dispatch,
  fileInfo,
  setResponseInfo,
  responseInfo,
}: QAProps) => {
  const [errorMessage, setErrorMessage] = useState<string>("");
  const { sendPrompt } = useSSEPrompt({ dispatch, setResponseInfo });

  const handleSend = async () => {
    try {
      setErrorMessage("");
      await sendPrompt(fileInfo, index);
    } catch (err) {
      if (err instanceof Error) {
        setErrorMessage(err.message);
      } else {
        setErrorMessage(String(err));
      }
    }
  };

  return (
    <div className="space-y-2 mb-4">
      {(status === "Loaded" || status === "Sended" || status === "Done") && (
        <div className="grid grid-cols-6 items-center">
          {/* --- filename row --- */}
          {/* column-A */}
          <div></div>
          {/* column-B */}
          <div className="text-gray-500 text-app-label">fname:</div>
          {/* column-C,D,E */}
          <div className="col-span-3 text-app-info">{fileInfo.filename}</div>
          {/* column-F */}
          <div className="col-span-1 row-span-2">
            <Button
              onClick={handleSend}
              disabled={status === "Sended" || status === "Done"}
              variant="ghost"
            >
              <SendHorizontal className="w-4 h-4 mr-2 text-ctm-blue-500" />
            </Button>
          </div>
          {/* --- mtime row --- */}
          {/* column-A */}
          <div></div>
          {/* column-B */}
          <div className="text-gray-500 text-app-label">mtime:</div>
          {/* column-C,D,E */}
          <div className="col-span-3 text-app-time text-gray-700">
            {formatDateTime(fileInfo.mtime)}
          </div>
          {/* column-F */}
          <div></div>

          {/* --- error message row --- */}
          {/* column-A */}
          <div></div>
          {/* column-B,C,D,E */}
          <div className="col-span-4 text-app-info">
            {errorMessage && (
              <div className="text-red-500 mt-2">{errorMessage}</div>
            )}
          </div>
          {/* column-F */}
          <div></div>
        </div>
      )}
      {(status === "Sended" || status === "Done") && (
        <div className="grid grid-cols-6 items-center">
          {/* --- avatar row --- */}
          {/* column-A */}
          <div>
            <Avatar className="bg-yellow-100">
              <AvatarImage src="/assistant.png" />
              <AvatarFallback>As</AvatarFallback>
            </Avatar>
          </div>
          {/* column-B */}
          <span className="text-app-avatar">Assistant</span>
          {/* column-C,D,E,F */}
          <div className="col-span-4"></div>

          {/* --- StreamEvent rows --- */}
          <div className="col-span-6">
            <StreamEvent status={status} responseInfo={responseInfo} />
          </div>
        </div>
      )}
    </div>
  );
};

export default QA;

## ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ (useSSEPrompt.tsx)
"use client";
import { useRef, useCallback } from "react";
import {
  Action,
  FileInfo,
  PromptRequest,
  ResponseInfo,
  StreamResponse,
  EventTypes,
} from "./types";

interface UseSSEPromptProps {
  dispatch: React.Dispatch<Action>;
  setResponseInfo: React.Dispatch<React.SetStateAction<ResponseInfo[]>>;
}

export const useSSEPrompt = ({
  dispatch,
  setResponseInfo,
}: UseSSEPromptProps) => {
  const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL;
  const esRef = useRef<EventSource | null>(null);

  // setEvent
  const setEvent = useCallback(
    (sres: StreamResponse, index: number) => {
      console.log("setEvent called");
      setResponseInfo((prev) => {
        const updated = [...prev];
        const prevEvents = updated[index]?.r_event ?? [];
        updated[index] = {
          r_event: [...prevEvents, { s_res: sres, r_time: new Date() }],
        };
        return updated;
      });
    },
    [setResponseInfo]
  );

  // handleGenericEvent
  const handleGenericEvent = useCallback(
    (
      type: (typeof EventTypes)[keyof typeof EventTypes],
      e: Event,
      index: number
    ) => {
      console.log(`- ${type} event -`);
      const data = JSON.parse((e as MessageEvent).data);
      console.log(`data: ${JSON.stringify(data, null, 2)}`);
      const sres: StreamResponse = {
        event: type as StreamResponse["event"],
        payload: data,
      };
      setEvent(sres, index);
    },
    [setEvent]
  );

  // sendPrompt
  const sendPrompt = useCallback(
    async (fileInfo: FileInfo, index: number) => {
      console.log("sendPrompt called");
      if (esRef.current) {
        // Prevent duplicate
        console.log("prevent duplicate");
        esRef.current.close();
        esRef.current = null;
      }

      try {
        // Create Session
        const requestBody: PromptRequest = { prompt: fileInfo.content };
        const res = await fetch(`${API_BASE}/main`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody),
        });
        if (!res.ok) throw new Error(`create session failed: ${res.status}`);

        const { session_id } = await res.json();
        if (!session_id) throw new Error("no session_id");
        console.log(`session_id: ${session_id}`);

        // Starting subscribing to SSE
        const url = `${API_BASE}/main/stream/${session_id}`;
        console.log("new EventSource");
        const es = new EventSource(url, { withCredentials: false });
        console.log(`es : ${es}`);

        // Listen "started" (special handling)
        es.addEventListener(EventTypes.STARTED, (e) => {
          console.log("- started event -");
          const data = JSON.parse((e as MessageEvent).data);
          console.log(`data: ${JSON.stringify(data, null, 2)}`);
          console.log("dispatch send_prompt");
          dispatch({ type: "SEND_PROMPT", index });
          const sres: StreamResponse = {
            event: EventTypes.STARTED,
            payload: data,
          };
          setResponseInfo((prev) => {
            const updated = [...prev];
            updated[index] = {
              r_event: [
                {
                  s_res: sres,
                  r_time: new Date(),
                },
              ],
            };
            return updated;
          });
        });

        // Listen "done" (special handling)
        es.addEventListener(EventTypes.DONE, (e) => {
          console.log("- done event -");
          const data = JSON.parse((e as MessageEvent).data);
          console.log(`data: ${JSON.stringify(data, null, 2)}`);
          const sres: StreamResponse = {
            event: EventTypes.DONE,
            payload: data,
          };
          setEvent(sres, index);

          es.close();
          esRef.current = null;
          console.log("dispatch done");
          dispatch({ type: "DONE", index });
        });

        // Other events (common handling)
        const commonEventTypes = Object.values(EventTypes).filter(
          (type) => type !== EventTypes.STARTED && type !== EventTypes.DONE
        );
        commonEventTypes.forEach((type) => {
          es.addEventListener(type, (e) => handleGenericEvent(type, e, index));
        });
      } catch (error) {
        console.log("Error sending: ", error);
        let message = "Failed to connect to server";
        if (error instanceof TypeError && error.message === "Failed to fetch") {
          message = "Could not connect to backend server";
        } else if (error instanceof Error) {
          message = error.message;
        }
        return Promise.reject(message);
      }
    },
    [API_BASE, dispatch, handleGenericEvent, setEvent, setResponseInfo]
  );

  return { sendPrompt };
};

## ç¾çŠ¶ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ (types.ts)
export type ChatStep = { status: "Unloaded" | "Loaded" | "Sended" | "Done" };
export type State = { steps: ChatStep[] };
export type Action =
  | { type: "LOAD_FILE"; index: number }
  | { type: "SEND_PROMPT"; index: number }
  | { type: "DONE"; index: number };
export type FileInfo = {
  filename: string;
  content: string;
  mtime: Date;
};
export type PromptRequest = {
  prompt: string;
};
export type PromptResponse = {
  prompt: string;
};

export type CheckResultPayload = {
  checker: string;
  result: boolean;
  rule_id: string;
  detail: string;
};

export type TestResultSpec = {
  title: string;
  result: boolean;
  error_summary: string | null;
  error_message: string | null;
  error_stack: string | null;
};

export type TestResultPayload = {
  name: string;
  file: string;
  result: boolean;
  detail: string;
  total: number;
  ok: number;
  ng: number;
  specs: TestResultSpec[];
};

export type TestScreenshotPayload = {
  spec: string;
  filename: string;
  url: string;
  updated: boolean;
};

export type StreamResponse =
  | {
      event: "started";
      payload: { status: string; message: string; step_id: string };
    }
  | {
      event: "code";
      payload: { language: string; code: string; file_path: string };
    }
  | { event: "agent_update"; payload: { agent_name: string } }
  | { event: "done"; payload: { status: string; message: string } }
  | { event: "check_result"; payload: CheckResultPayload }
  | { event: "system_error"; payload: { error: string; detail: string } }
  | {
      event: "agent_result";
      payload: { result: boolean; error_detail: string };
    }
  | { event: "test_result"; payload: TestResultPayload }
  | { event: "test_screenshot"; payload: TestScreenshotPayload };

export type ResponseEvent = {
  s_res: StreamResponse;
  r_time: Date;
};

export type ResponseInfo = {
  r_event: ResponseEvent[];
};

export const EventTypes = {
  STARTED: "started",
  CODE: "code",
  AGENT_UPDATE: "agent_update",
  DONE: "done",
  CHECK_RESULT: "check_result",
  SYSTEM_ERROR: "system_error",
  AGENT_RESULT: "agent_result",
  TEST_RUN: "test_run",
  TEST_RESULT: "test_result",
  TEST_SCREENSHOT: "test_screenshot",
} as const;

export type CheckResultEvent = {
  event: "check_result";
  payload: CheckResultPayload;
};

export type CheckResultItem = {
  s_res: CheckResultEvent;
  r_time: Date;
};

export type Mode = "Manual" | "Auto";

export type AutoRunFilelist = {
  name: string;
  content: string;
  mtime: string; // ISO8601
};

export type FileNode = {
  type: "file";
  name: string;
  data: AutoRunFilelist;
};
export type DirectoryNode = {
  type: "directory";
  name: string;
  children: TreeNode[];
};
export type TreeNode = FileNode | DirectoryNode;

export enum Emoji {
  WHITE_CIRCLE = "\u26AA", // âšª
  RED_CIRCLE = "\u{1F534}", // ğŸ”´
  BLUE_CIRCLE = "\u{1F535}", // ğŸ”µ
  GREEN_CIRCLE = "\u{1F7E2}", // ğŸŸ¢
}

export enum ResponseStatus {
  COMPLETED = "Completed",
  FAILED = "Failed",
}

[Answer]
1. å…¨ä½“ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨å‡¦ç†æ¦‚è¦
1.1 ç”»é¢æ§‹æˆï¼ˆpage.tsxï¼‰

page.tsx ã¯ ã‚¢ãƒ—ãƒªå…¨ä½“ã®ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ ã§ã™ã€‚

ç®¡ç†ã—ã¦ã„ã‚‹ä¸»ãªçŠ¶æ…‹
| state                | å½¹å‰²                                                 |
| -------------------- | -------------------------------------------------- |
| `state (useReducer)` | å„ Step ã®é€²è¡ŒçŠ¶æ…‹ï¼ˆUnloaded / Loaded / Sended / Doneï¼‰    |
| `fileInfo[]`         | å„ Step ã«å¯¾å¿œã™ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ï¼ˆfilename / content / mtimeï¼‰ |
| `responseInfo[]`     | å„ Step ã«å¯¾å¿œã™ã‚‹ SSE ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°çµæœ                         |
| `mode`               | Manual / Auto ã® UI ãƒ¢ãƒ¼ãƒ‰                             |

é‡è¦ãªè¨­è¨ˆãƒã‚¤ãƒ³ãƒˆ
- Step index ã‚’ã‚­ãƒ¼ã«ã™ã¹ã¦ã®çŠ¶æ…‹ãŒç´ã¥ã
  - steps[index]
  - fileInfo[index]
  - responseInfo[index]
- Step ãŒå¢—ãˆãŸã‚‰ fileInfo ã‚‚è‡ªå‹•ã§æ‹¡å¼µã•ã‚Œã‚‹è¨­è¨ˆ
- å®Ÿéš›ã®å‡¦ç†ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ­ãƒ¼ãƒ‰ãƒ»é€ä¿¡ãƒ»SSEå—ä¿¡ï¼‰ã¯ å­ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«å§”è­²

1.2 ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã€œé€ä¿¡ã®æµã‚Œï¼ˆä¿¯ç°ï¼‰
FileUploader
  â†“ï¼ˆfileInfo[index] æ›´æ–° + dispatch LOAD_FILEï¼‰
QA
  â†“ sendPrompt()
useSSEPrompt
  â†“ POST /main
  â†“ GET /main/stream/{session_id} (SSE)
  â†“ responseInfo[index] ã«ã‚¤ãƒ™ãƒ³ãƒˆè“„ç©
StreamEvent / StreamDetail
  â†“ è¡¨ç¤º

2. QA.tsx ã®å½¹å‰²
QA.tsx ã¯ ã€Œã“ã® Step ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ã™ã‚‹ UI + çµæœè¡¨ç¤ºã€ ã‚’æ‹…ã£ã¦ã„ã¾ã™ã€‚

è²¬å‹™
- Send ãƒœã‚¿ãƒ³ã®åˆ¶å¾¡
- useSSEPrompt ã‚’ä½¿ã£ãŸé€ä¿¡ãƒˆãƒªã‚¬ãƒ¼
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
- ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°çµæœï¼ˆAssistant ç™ºè©±ï¼‰ã®è¡¨ç¤º

sendPrompt ã®å‘¼ã³å‡ºã—æ¡ä»¶
const { sendPrompt } = useSSEPrompt({ dispatch, setResponseInfo });
await sendPrompt(fileInfo, index);

ã“ã“ã§é‡è¦ãªã®ã¯ï¼š
- sendPrompt ã¯ fileInfo ã¨ index ã«å®Œå…¨ã«ä¾å­˜
- UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè‡ªä½“ã¯ SSE ã®è©³ç´°ã‚’çŸ¥ã‚‰ãªã„
ğŸ‘‰ QA ã¯ã€Œé€ä¿¡ã®å…¥å£ã€ã«ã™ããšã€ãƒ­ã‚¸ãƒƒã‚¯ã¯ hook ã«é›†ç´„ã•ã‚Œã¦ã„ã‚‹

3. useSSEPrompt.ts ã®è©³ç´°è§£æ
3.1 useSSEPrompt ã®æ­£ä½“
useSSEPrompt ã¯ä»¥ä¸‹ã‚’ã¾ã¨ã‚ãŸ SSEå°‚ç”¨ã®ãƒ­ã‚¸ãƒƒã‚¯ hook ã§ã™ã€‚
- ã‚»ãƒƒã‚·ãƒ§ãƒ³ç”Ÿæˆï¼ˆPOSTï¼‰
- EventSource ã®ç”Ÿæˆã¨ç®¡ç†
- SSEã‚¤ãƒ™ãƒ³ãƒˆã®æŒ¯ã‚Šåˆ†ã‘
- dispatch ã¨ setResponseInfo ã®æ›´æ–°

å†…éƒ¨çŠ¶æ…‹
const esRef = useRef<EventSource | null>(null);
ğŸ‘‰ 1 hook = 1 SSEæ¥ç¶š ã¨ã„ã†è¨­è¨ˆ

3.2 sendPrompt ã®å‡¦ç†ãƒ•ãƒ­ãƒ¼
â‘  é‡è¤‡é˜²æ­¢
if (esRef.current) {
  esRef.current.close();
  esRef.current = null;
}
åŒä¸€ hook ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å†…ã§ã¯ å¤šé‡æ¥ç¶šä¸å¯

â‘¡ ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆï¼ˆHTTPï¼‰
POST /main
{ prompt: fileInfo.content }
- ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã® ä¸­èº«ã®ã¿ ã‚’é€ä¿¡
- filename ã‚„ mtime ã¯é€ã£ã¦ã„ãªã„ï¼ˆUIç”¨é€”ï¼‰

â‘¢ SSE æ¥ç¶šé–‹å§‹
GET /main/stream/{session_id}

â‘£ SSEã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
startedï¼ˆç‰¹åˆ¥æ‰±ã„ï¼‰
- dispatch({ type: "SEND_PROMPT", index })
- responseInfo[index] ã‚’åˆæœŸåŒ–

doneï¼ˆç‰¹åˆ¥æ‰±ã„ï¼‰
- æœ€çµ‚ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ 
- dispatch({ type: "DONE", index })
- SSE åˆ‡æ–­

ãã®ä»–ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå…±é€šï¼‰
- handleGenericEvent â†’ setEvent
- responseInfo[index].r_event[] ã« append

3.3 useSSEPrompt ãŒè¦æ±‚ã™ã‚‹ã€Œå¤–éƒ¨ä¾å­˜ã€
sendPrompt() ã‚’å‘¼ã¶ãŸã‚ã« å¿…é ˆãªã‚‚ã®

| ä¾å­˜                 | ç†ç”±                            |
| ------------------ | ----------------------------- |
| `dispatch`         | Step çŠ¶æ…‹ç®¡ç†ï¼ˆSEND_PROMPT / DONEï¼‰ |
| `setResponseInfo`  | SSEã‚¤ãƒ™ãƒ³ãƒˆã®è“„ç©                    |
| `index`            | Step / response ã®å¯¾å¿œä»˜ã‘         |
| `fileInfo.content` | ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæœ¬æ–‡                       |

4. types.ts ã‹ã‚‰è¦‹ãˆã‚‹è¨­è¨ˆæ€æƒ³
æ˜ç¢ºãªãƒã‚¤ãƒ³ãƒˆ
- SSEã‚¤ãƒ™ãƒ³ãƒˆã¯ union type ã§å³å¯†ã«å®šç¾©
- EventTypes ã¯ SSE event åã¨ 1:1 å¯¾å¿œ
- ResponseInfo ã¯ã€Œã‚¤ãƒ™ãƒ³ãƒˆã®æ™‚ç³»åˆ—ãƒ­ã‚°ã€

ResponseInfo = {
  r_event: { s_res, r_time }[]
}

ğŸ‘‰ UIã¯ã€ŒçŠ¶æ…‹ã€ã§ã¯ãªãã€Œå±¥æ­´ã€ã‚’æç”»ã—ã¦ã„ã‚‹

5. sendPrompt() ã‚’ã€Œåˆ¥ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‹ã‚‰ä½¿ãˆã‚‹ã‹ï¼Ÿã€
çµè«–ï¼ˆé‡è¦ï¼‰

âœ… æŠ€è¡“çš„ã«ã¯å¯èƒ½
â— ãŸã ã—ã€æ¡ä»¶ä»˜ã

5.1 å‘¼ã³å‡ºã—å¯èƒ½ãªç†ç”±
- sendPrompt ã¯ UIã«ä¾å­˜ã—ã¦ã„ãªã„
- å¿…è¦ãªã®ã¯ä»¥ä¸‹ã ã‘ï¼š
useSSEPrompt({
  dispatch,
  setResponseInfo,
});
ğŸ‘‰ QA å°‚ç”¨ã§ã¯ãªã„ã€æ±ç”¨ hook

5.2 å‘¼ã³å‡ºã™ãŸã‚ã®å¿…é ˆæ¡ä»¶ï¼ˆæ•´ç†ï¼‰

æ–°ã—ã„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‹ã‚‰ sendPrompt ã‚’ä½¿ã†ã«ã¯ã€ä»¥ä¸‹ãŒæƒã£ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

â‘  Stepç®¡ç†ï¼ˆdispatchï¼‰
- SEND_PROMPT
- DONE
ã‚’å‡¦ç†ã§ãã‚‹ reducer ãŒå­˜åœ¨ã™ã‚‹ã“ã¨
ğŸ‘‰ page.tsx ã® reducer ã‚’ å…±æœ‰ or ä¸Šä½ã§ç®¡ç† ã™ã‚‹å¿…è¦ã‚ã‚Š

â‘¡ responseInfo ã®ç®¡ç†
- ResponseInfo[]
- setResponseInfo
ğŸ‘‰ responseInfo ã‚’ QAå°‚ç”¨ state ã«ã—ã¦ã„ã‚‹ã¨å†åˆ©ç”¨ä¸å¯

â‘¢ index ã®æ„å‘³ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã“ã¨
- index ã¯ responseInfo / steps / fileInfo ã®å…±é€šã‚­ãƒ¼
ğŸ‘‰ Autoãƒ¢ãƒ¼ãƒ‰ãªã©ã§ã¯ï¼š
- ä»®æƒ³ Step
- å›ºå®š indexï¼ˆä¾‹: 0ï¼‰
- ç‹¬ç«‹ã—ãŸ state ç®¡ç†
ã®ã©ã‚Œã‹ã‚’é¸ã¶å¿…è¦ã‚ã‚Š

â‘£ SSE æ¥ç¶šã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«è¨­è¨ˆ
- åŒä¸€ hook ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å†…ã§ã¯ åŒæ™‚ã«1æ¥ç¶š
- è¤‡æ•°ä¸¦åˆ—å®Ÿè¡Œã—ãŸã„å ´åˆï¼š
  - hook ã‚’ è¤‡æ•°ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
  - or hook ã‚’ class / service åŒ–

6. æ”¹ä¿®æ–¹é‡ã®æ•´ç†ï¼ˆä»Šå¾Œã®æ‹¡å¼µã‚’è¦‹æ®ãˆã¦ï¼‰
æ–¹é‡â‘  sendPrompt ã‚’ã€ŒUIéä¾å­˜ã®ä¸­æ ¸APIã€ã«ä½ç½®ä»˜ã‘ã‚‹
- QA / Auto / Batch å®Ÿè¡Œã§å…±é€šåˆ©ç”¨
- å‘¼ã³å‡ºã—å´ã¯ï¼š
  - prompt
  - step index
  - è¡¨ç¤ºæ–¹æ³•
ã ã‘ã‚’åˆ¶å¾¡

æ–¹é‡â‘¡ State ã‚’ä¸Šä½ã«é›†ç´„
page.tsx
 â”œâ”€ state (steps)
 â”œâ”€ fileInfo
 â”œâ”€ responseInfo
 â””â”€ useSSEPrompt

ğŸ‘‰ æ–°ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚‚ åŒã˜ state ã‚’ä½¿ã†

æ–¹é‡â‘¢ å°†æ¥ã®åˆ†é›¢æ¡ˆï¼ˆä¸­ã€œé•·æœŸï¼‰
- useSSEPrompt
  â†’ SSEClientï¼ˆç´”ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
- React hook ã¯ è–„ã„ãƒ©ãƒƒãƒ‘ãƒ¼

ã“ã‚Œã«ã‚ˆã‚Šï¼š
- ä¸¦åˆ—é€ä¿¡
- AutoRun
- ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§
ãŒå‘ä¸Š

7. ä¸è¶³æƒ…å ±ã¨ã—ã¦ç¢ºèªã—ãŸã„ç‚¹ï¼ˆå¿…è¦æœ€å°é™ï¼‰

ä»¥ä¸‹ã¯ è¨­è¨ˆåˆ¤æ–­ã«å½±éŸ¿ã™ã‚‹ãŸã‚ç¢ºèªã—ãŸã„ãƒã‚¤ãƒ³ãƒˆ ã§ã™ã€‚
1.æ–°ãŸã«ä½œæˆäºˆå®šã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯
  - æ—¢å­˜ Step ã¨ åŒã˜ steps / responseInfo ã‚’ä½¿ã† æƒ³å®šã§ã™ã‹ï¼Ÿ
  - ãã‚Œã¨ã‚‚ ç‹¬ç«‹ã—ãŸå®Ÿè¡Œå˜ä½ ã§ã™ã‹ï¼Ÿ

2.åŒæ™‚ã«è¤‡æ•°ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ ä¸¦åˆ—é€ä¿¡ ã™ã‚‹å¯èƒ½æ€§ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ

ã“ã®2ç‚¹ãŒåˆ†ã‹ã‚Œã°ã€
ã€Œhookå†åˆ©ç”¨ã€ã‹ã€ŒSSEã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆ†é›¢ã€ã‹ ã‚’æ˜ç¢ºã«ææ¡ˆã§ãã¾ã™ã€‚

[Question-2]
1.æ–°ãŸã«ä½œæˆäºˆå®šã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«ã¤ã„ã¦
ç¾åœ¨é–‹ç™ºä¸­ã§é€”ä¸­ã¾ã§ä½œæˆãŒå®Œäº†ã—ã¦ã„ã¾ã™ã€‚
page.tsxã§å®šç¾©ã—ã¦ã„ã‚‹<AutoBlock>ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‹ã‚‰ã€<AutoRunLoader>ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã€APIã‚µãƒ¼ãƒã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆã‚’å—ä¿¡ã—ã€<TreeView>ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§è§£æã—ã€setTree(data)ã§ä¿æŒã—ã¦ã„ã¾ã™ã€‚
ç¾çŠ¶ã¯AutoRunLoaderã®ä¸Šä½ã®AutoBlockã§treeãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã‚’æœ€ä¸Šä½ã®page.tsxã«æŒãŸã›ã‚Œã°è‰¯ã„ã®ã§ã¯ãªã„ã‹ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

ã“ã®treeãƒ‡ãƒ¼ã‚¿ã§ä¿æŒã—ã¦ã„ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ–‡ã‚’ã€ã€Œå®Ÿè¡Œã€ãƒœã‚¿ãƒ³ï¼ˆã“ã‚Œã‹ã‚‰è¿½åŠ ã™ã‚‹ï¼‰æŠ¼ä¸‹å¾Œã«ã€ãƒ‡ãƒ¼ã‚¿ç™»éŒ²é †ã«å¾“ã„ã€é †æ¬¡APIã‚µãƒ¼ãƒã«é€ä¿¡ã—ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’éƒ½åº¦ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ãªãã€è‡ªå‹•çš„ã«é †æ¬¡ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ–‡ã‚’é€ä¿¡ã—ãŸã„ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

  - é€ä¿¡ã™ã‚‹éš›ã¯sendPrompté–¢æ•°ã‚’ä½¿ã„ãŸã„ã€‚ãªãœãªã‚‰ã€"started"ã‚¤ãƒ™ãƒ³ãƒˆã¨"done"ã‚¤ãƒ™ãƒ³ãƒˆå—ä¿¡æ™‚ã«dispatch()å‡¦ç†ãªã©ã®çŠ¶æ…‹å¤‰æ›´å‡¦ç†ã‚’è¡Œã£ã¦ãŠã‚Šã€ã“ã‚Œã‚‰ã®å‡¦ç†ã¯è¸è¥²ã—ãŸã„ã‹ã‚‰ã€‚
  - "done"ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã§statusãŒæ­£å¸¸ã‹ç•°å¸¸ã‹ã«ã‚ˆã£ã¦ã€æ¬¡ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ–‡ã‚’é€ä¿¡ã™ã‚‹ã‹ã€ä¸­æ–­ã™ã‚‹ã‹ã®åˆ¤æ–­ãƒ­ã‚¸ãƒƒã‚¯ã‚‚åŠ ãˆãŸã„ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

2.åŒæ™‚ã«è¤‡æ•°ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ ä¸¦åˆ—é€ä¿¡ ã™ã‚‹å¯èƒ½æ€§
ä¸Šè¨˜ã®é€šã‚Šã€é †æ¬¡é€ä¿¡ã™ã‚‹ã“ã¨ã‚’è€ƒãˆã¦ãŠã‚Šã€ä¸¦åˆ—é€ä¿¡ã¯è€ƒãˆã¦ãŠã‚Šã¾ã›ã‚“ã€‚

## AutoRunLoader.tsx
"use client";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { TreeNode } from "./types";
import { useState } from "react";
import TreeView from "./TreeView";

interface AutoRunLoaderProps {
  tree: TreeNode[];
  setTree: React.Dispatch<React.SetStateAction<TreeNode[]>>;
}

const AutoRunLoader: React.FC<AutoRunLoaderProps> = ({ tree, setTree }) => {
  const [autorunId, setAutorunId] = useState("");
  const [inputAutorunId, setInputAutorunId] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [errorDetail, setErrorDetail] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const buildUserMessage = (status: number): string => {
    switch (status) {
      case 404:
        return "AutoRunID not found";
      case 422:
        return "Directory structure is too deep";
      case 500:
        return "Internal Error";
      default:
        return "Failed to load file list";
    }
  };

  const handleLoad = async () => {
    setLoading(true);
    setError(null);
    setErrorDetail(null);

    try {
      const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL;
      const params = new URLSearchParams({ autorun_id: inputAutorunId });
      const res = await fetch(
        `${API_BASE}/autorun/filelist?${params.toString()}`,
        {
          method: "GET",
        }
      );
      if (!res.ok) {
        const body = await res.json().catch(() => null);
        setError(buildUserMessage(res.status));
        setErrorDetail(body?.detail ?? null);
        return;
      }
      const data: TreeNode[] = await res.json();
      console.log("TreeNode data: ", data);
      setTree(data);
      setAutorunId(inputAutorunId);
    } catch (e) {
      setError("Network Error");
      setErrorDetail(String(e));
    } finally {
      setLoading(false);
    }
  };

  const isLoadDisabled = loading || inputAutorunId.trim().length === 0;

  return (
    <div className="flex flex-col">
      <Label className="mt-2">AutoRunID</Label>
      <Input
        id="autorun-id"
        placeholder="dir, dir/subdir"
        value={inputAutorunId}
        onChange={(e) => setInputAutorunId(e.target.value)}
        className="border-0 border-b rounded-none focus-visible:ring-0 h-6 mt-1"
      />
      <Button
        size="sm"
        onClick={handleLoad}
        disabled={isLoadDisabled}
        variant="ghost"
        className="
          shrink-0
          text-ctm-blue-500
          hover:text-ctm-blue-600
          hover:bg-transparent 
          mt-1
        "
      >
        {loading ? "Loading..." : "Load"}
      </Button>

      {error && (
        <div className="text-xs text-red-500">
          <div>{error}</div>
          {errorDetail && (
            <details className="mt-1 cursor-pointer">
              <summary className="text-xs">detail</summary>
              <p className="text-xs">{errorDetail}</p>
            </details>
          )}
        </div>
      )}

      {tree.length > 0 && (
        <div className="mt-4 border-t pt-2">
          <div className="font-semibold mb-1">{autorunId}</div>
          <TreeView nodes={tree} />
        </div>
      )}
    </div>
  );
};

export default AutoRunLoader;

## TreeView.tsx
"use client";
import { TreeNode } from "./types";
import { formatDateTime } from "./util";

interface TreeViewProps {
  nodes: TreeNode[];
  depth?: number;
}

const indentClass = (depth: number) => `ml-${depth * 2}`;

const TreeView: React.FC<TreeViewProps> = ({ nodes, depth = 0 }) => {
  return (
    <ul className="text-sm">
      {nodes.map((node, index) => {
        if (node.type === "directory") {
          return (
            <li key={`${node.name}-${index}`} className={indentClass(depth)}>
              <div className="font-medium">- {node.name}</div>
              <TreeView nodes={node.children} depth={depth + 1} />
            </li>
          );
        }

        // file
        return (
          <li key={`${node.name}-${index}`} className={indentClass(depth)}>
            <div>- {node.name}</div>
            <div className="ml-2 text-xs text-muted-foreground">
              {formatDateTime(new Date(node.data.mtime))}
            </div>
          </li>
        );
      })}
    </ul>
  );
};

export default TreeView;

[Answer-2]
ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚
ã„ãŸã ã„ãŸè¿½åŠ æƒ…å ±ã‚’è¸ã¾ãˆã¦ã€ç¾çŠ¶è¨­è¨ˆã®æ•´ç† â†’ Autoå®Ÿè¡Œã«æ‹¡å¼µã™ã‚‹éš›ã®è¨­è¨ˆæ–¹é‡ â†’ sendPrompt å†åˆ©ç”¨ã®å¯å¦ã¨æ¡ä»¶ â†’ å…·ä½“çš„ãªæ”¹ä¿®æ–¹é‡ ã®é †ã§ã¾ã¨ã‚ã¾ã™ã€‚

1. ç¾çŠ¶è¨­è¨ˆã®å†æ•´ç†ï¼ˆManual / Auto ã‚’ä¿¯ç°ï¼‰
1.1 ç¾åœ¨ã® Manual å®Ÿè¡Œãƒ¢ãƒ‡ãƒ«ï¼ˆQAä¸­å¿ƒï¼‰

çŠ¶æ…‹ã®è»¸
- Step index ãŒã™ã¹ã¦ã®ã‚­ãƒ¼
  - steps[index]
  - fileInfo[index]
  - responseInfo[index]

å®Ÿè¡Œãƒ¢ãƒ‡ãƒ«
- äººãŒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
- äººãŒ Send ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™
- sendPrompt(fileInfo, index)
- SSE "started" â†’ dispatch(SEND_PROMPT)
- SSE "done" â†’ dispatch(DONE)
ğŸ‘‰ ã€Œ1 Step = 1 ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã€ ã¨ã„ã†å¼·ã„å‰æãŒã‚ã‚‹

1.2 ç¾åœ¨ã® AutoRun ç³»ã®çŠ¶æ…‹
AutoRunLoader / TreeView
- API /autorun/filelist ã‹ã‚‰ TreeNode æ§‹é€  ã‚’å–å¾—
- TreeNode.data.content ã« ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæœ¬æ–‡ãŒã™ã§ã«å«ã¾ã‚Œã¦ã„ã‚‹
- ã¤ã¾ã‚Šï¼š
  - ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ­ãƒ¼ãƒ‰ã¯ä¸è¦
  - AutoRun ç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¯ã€Œã™ã§ã«ãƒ¡ãƒ¢ãƒªä¸Šã«ã‚ã‚‹ã€

2. ã”ææ¡ˆã®ã€Œtree ã‚’ page.tsx ã«æŒãŸã›ã‚‹ã€ã«ã¤ã„ã¦
çµè«–

âœ… è¨­è¨ˆçš„ã«æ­£ã—ã„åˆ¤æ–­
ã‚€ã—ã‚ Auto å®Ÿè¡Œã‚’è€ƒãˆã‚‹ã¨ å¿…é ˆã«è¿‘ã„
ç†ç”±
â‘  Auto ã¯ã€Œã‚¢ãƒ—ãƒªå…¨ä½“ã®å®Ÿè¡Œãƒ•ãƒ­ãƒ¼ã€

AutoRun ã¯ï¼š
- QA ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…éƒ¨ã®å‡¦ç†ã§ã¯ãªã„
- æ‰‹å‹•æ“ä½œã§ã‚‚ãªã„
- ã‚¢ãƒ—ãƒªå…¨ä½“ã®åˆ¶å¾¡ãƒ­ã‚¸ãƒƒã‚¯
ğŸ‘‰ page.tsx ãŒã€Œå¸ä»¤å¡”ã€ã§ã‚ã‚‹ã®ãŒè‡ªç„¶

â‘¡ tree ã¯ã€Œæ¬¡ã«ä½•ã‚’å®Ÿè¡Œã™ã‚‹ã‹ã€ã‚’æ±ºã‚ã‚‹çŠ¶æ…‹

tree ã¯ï¼š
- å˜ãªã‚‹è¡¨ç¤ºç”¨ãƒ‡ãƒ¼ã‚¿ã§ã¯ãªã
- å®Ÿè¡Œé †åºãƒ»å†…å®¹ã‚’è¦å®šã™ã‚‹ãƒ‡ãƒ¼ã‚¿
ã“ã‚Œã¯ï¼š
- fileInfo
- steps
ã¨åŒã˜ãƒ¬ã‚¤ãƒ¤ãƒ¼ã® state

â‘¢ Auto / Manual ã®å…±å­˜ãŒæ¥½ã«ãªã‚‹
page.tsx
 â”œâ”€ steps
 â”œâ”€ fileInfo      â† Manual ç”¨
 â”œâ”€ responseInfo
 â”œâ”€ tree          â† Auto ç”¨
 â””â”€ mode

ã“ã®æ§‹é€ ã«ã™ã‚‹ã¨ï¼š
- Manualï¼šfileInfo â†’ sendPrompt
- Autoï¼štree â†’ sendPrompt

ã¨ å…¥å£ã ã‘åˆ‡ã‚Šæ›¿ãˆã‚‹ å½¢ã«ãªã‚‹

3. Auto å®Ÿè¡Œã§ã‚„ã‚ŠãŸã„ã“ã¨ã‚’æ§‹é€ åŒ–
ã”è¦æœ›ã‚’ãƒ­ã‚¸ãƒƒã‚¯ã«è½ã¨ã™ã¨ã€æ¬¡ã®çŠ¶æ…‹æ©Ÿæ¢°ã«ãªã‚Šã¾ã™ã€‚

[Idle]
  â†“ å®Ÿè¡Œãƒœã‚¿ãƒ³
[Running step 0]
  â†“ done (success)
[Running step 1]
  â†“ done (failure)
[Abort]

ç‰¹å¾´
- å¿…ãšç›´åˆ—
- "done" ã‚¤ãƒ™ãƒ³ãƒˆãŒãƒˆãƒªã‚¬ãƒ¼
- done.payload.status ã«ã‚ˆã£ã¦åˆ†å²
ğŸ‘‰ SSE ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ã¨å®Œå…¨ã«ä¸€è‡´

4. sendPrompt ã¯ Auto ã‹ã‚‰ä½¿ãˆã‚‹ã‹ï¼Ÿ
çµè«–ï¼ˆæ˜ç¢ºï¼‰
âœ… å®Œå…¨ã«ä½¿ãˆã‚‹
â— ãŸã ã—ã€Œå‘¼ã³å‡ºã—æ–¹ã€ã‚’å°‘ã—å¤‰ãˆã‚‹å¿…è¦ã‚ã‚Š

ãªãœä½¿ãˆã‚‹ã®ã‹
- sendPrompt ãŒã‚„ã£ã¦ã„ã‚‹æœ¬è³ªã¯ï¼š
  1.ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ
  2.SSE æ¥ç¶š
  3.started / done ã§ dispatch
  4.responseInfo æ›´æ–°
ã“ã‚Œã‚‰ã¯ï¼š
  - Manual / Auto ã®åŒºåˆ¥ãŒãªã„
  -ã€Œãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ–‡å­—åˆ—ã€ã•ãˆã‚ã‚Œã°æˆç«‹

Auto ç”¨ã«è¿½åŠ ã§å¿…è¦ãªæ¡ä»¶
æ¡ä»¶â‘  fileInfo ã‚’ã€Œä»®æƒ³çš„ã«ä½œã‚‹ã€

Auto ã§ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ãªã„ã®ã§ï¼š
const fileInfo: FileInfo = {
  filename: node.name,
  content: node.data.content,
  mtime: new Date(node.data.mtime),
};
ğŸ‘‰ sendPrompt ã¯ FileInfo ã® content ã—ã‹ä½¿ã£ã¦ã„ãªã„

æ¡ä»¶â‘¡ index ã‚’ Auto ç”¨ã«æ„å‘³ä»˜ã‘ã™ã‚‹
é¸æŠè‚¢ã¯2ã¤ï¼š

æ¡ˆAï¼ˆãŠã™ã™ã‚ï¼‰
  - Auto å®Ÿè¡Œç”¨ã« å°‚ç”¨ã® steps / responseInfo ã‚’æŒã¤
  - index = å®Ÿè¡Œé †ï¼ˆ0, 1, 2 ...ï¼‰

æ¡ˆB
  - Manual ã¨åŒã˜ steps ã‚’æµç”¨
  - Auto é–‹å§‹æ™‚ã« steps ã‚’ã¾ã¨ã‚ã¦ç”Ÿæˆ

  steps = treeFiles.map(() => ({ status: "Loaded" }));

æ¡ä»¶â‘¢ done ã‚’ã€Œå¾…ã£ã¦ã‹ã‚‰æ¬¡ã‚’é€ã‚‹ã€
ç¾åœ¨ã® sendPrompt ã¯ï¼š
  - done ã‚’ UIæ›´æ–°ã®ã‚¤ãƒ™ãƒ³ãƒˆ ã¨ã—ã¦æ‰±ã£ã¦ã„ã‚‹
  - å‘¼ã³å‡ºã—å…ƒã«çµæœã‚’è¿”ã•ãªã„
ğŸ‘‰ Auto ç”¨ã«ã¯ done ã‚’ãƒ•ãƒƒã‚¯ã™ã‚‹å¿…è¦ãŒã‚ã‚‹

5. Auto å®Ÿè¡Œã«å‘ã‘ãŸæœ€å°æ”¹ä¿®æ–¹é‡ï¼ˆé‡è¦ï¼‰
æ–¹é‡ã®è»¸

sendPrompt ã¯å¤‰ãˆãªã„ / ã‚‚ã—ãã¯æœ€å°é™ã®æ‹¡å¼µã«ç•™ã‚ã‚‹

5.1 Auto å®Ÿè¡Œç”¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚’ä½œã‚‹
ã‚¤ãƒ¡ãƒ¼ã‚¸
const runAuto = async () => {
  for (let i = 0; i < files.length; i++) {
    await sendPrompt(fileInfo, i);
    await waitForDone(i);

    if (lastDoneStatus !== "success") break;
  }
};

5.2 ã€Œdone ã‚’å¾…ã¤ã€æ–¹æ³•ï¼ˆè¨­è¨ˆä¸Šã®æ ¸å¿ƒï¼‰
æ–¹æ³•Aï¼ˆãŠã™ã™ã‚ãƒ»Reactçš„ï¼‰
- responseInfo ã‚’ç›£è¦–ã™ã‚‹
- "done" ã‚¤ãƒ™ãƒ³ãƒˆãŒè¿½åŠ ã•ã‚ŒãŸã‚‰ resolve

useEffect(() => {
  const events = responseInfo[currentIndex]?.r_event;
  const done = events?.find(e => e.s_res.event === "done");
  if (done) {
    // æ¬¡ã¸
  }
}, [responseInfo, currentIndex]);

âœ” sendPrompt éæ”¹ä¿®
âœ” UI ã¨æ•´åˆçš„

æ–¹æ³•Bï¼ˆsendPrompt ã‚’ Promise åŒ–ï¼‰

sendPrompt ã‚’æ‹¡å¼µï¼š
const sendPrompt = async (...) => {
  return new Promise<DonePayload>((resolve, reject) => {
    es.addEventListener("done", (e) => {
      resolve(parsedData);
    });
  });
};

âœ” Auto ã¯æ›¸ãã‚„ã™ã„
âŒ Manual å´ã¸ã®å½±éŸ¿ã‚’è¦æ¤œè¨

5.3 status ã«ã‚ˆã‚‹ä¸­æ–­åˆ¤å®š
if (done.payload.status !== "success") {
  abortAutoRun();
}

ã“ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ï¼š
- AutoBlock / page.tsx ã«ç½®ã
- useSSEPrompt ã«ã¯å…¥ã‚Œãªã„
ğŸ‘‰ ã€Œå®Ÿè¡Œãƒãƒªã‚·ãƒ¼ã€ã¨ã€Œé€šä¿¡ã€ã¯åˆ†é›¢

6. æ¨å¥¨ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆã¾ã¨ã‚ï¼‰
page.tsx
 â”œâ”€ steps
 â”œâ”€ responseInfo
 â”œâ”€ tree
 â”œâ”€ useSSEPrompt
 â”œâ”€ QA (Manual)
 â””â”€ AutoBlock
     â”œâ”€ AutoRunLoader
     â”œâ”€ TreeView
     â””â”€ AutoRunner â† â˜…æ–°è¦

AutoRunner ã®è²¬å‹™
- tree ã‚’å®Ÿè¡Œé †ã« flatten
- index ã‚’ç®¡ç†
- sendPrompt ã‚’é †æ¬¡å‘¼ã³å‡ºã—
- done ã‚’ç›£è¦–
- æˆå¦åˆ¤å®šãƒ»ä¸­æ–­

